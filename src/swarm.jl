"""
    ParticleSwarm(n_particles = 3,
                  w = 1.0,
                  c1 = 2.0,
                  c2 = 2.0,
                  prob_shift = 0.25,
                  rng = Random.GLOBAL_RNG)

Instantiate a particle swarm optimization tuning strategy. A swarm is initiated
by sampling hyperparameters with their customizable priors, and new models are
generated by referencing each member's and the swarm's best models so far.

### Supported ranges

A single one-dimensional range or vector of one-dimensional ranges can be
specified. `ParamRange` objects are constructed using the `range` method. If not
paired with a prior, then one is fitted, as follows:

| Range Types             | Default Distribution |
|:----------------------- |:-------------------- |
| `NominalRange`          | `Dirichlet`          |
| Bounded `NumericRange`  | `Uniform`            |
| Positive `NumericRange` | `Gamma`              |
| Other `NumericRange`    | `Normal`             |

Specifically, in `ParticleSwarm`, the `range` field of a `TunedModel` instance
can be:

- a single one-dimensional range (`ParamRange` object) `r`

- a pair of the form `(r, d)`, with `r` as above and where `d` is:

    - a Dirichlet distribution with the same number of categories as `r.values`
      (for `NominalRange` `r`)

    - any `Distributions.UnivariateDistribution` *instance* (for `NumericRange`
      `r`)

    - one of the distribution *types* in the table below, for automatic fitting
      using `Distributions.fit(d, r)` to a distribution whose support always
      lies between `r.lower` and `r.upper` (for `NumericRange` `r`) or the set
      of probability vectors (for `NominalRange` `r`)

- any vector of objects of the above form

| Range Types             | Distribution Types                                                                           |
|:----------------------- |:-------------------------------------------------------------------------------------------- |
| `NominalRange`          | `Dirichlet`                                                                                  |
| Bounded `NumericRange`  | `Arcsine`, `Uniform`, `Biweight`, `Cosine`, `Epanechnikov`, `SymTriangularDist`, `Triweight` |
| Positive `NumericRange` | `Gamma`, `InverseGaussian`, `Poisson`                                                        |
| Any `NumericRange`      | `Normal`, `Logistic`, `LogNormal`, `Cauchy`, `Gumbel`, `Laplace`                             |

### Examples

    using Distributions

    range1 = range(model, :hyper1, lower=0, upper=1)

    range2 = [(range(model, :hyper1, lower=1, upper=10), Arcsine),
              range(model, :hyper2, lower=2, upper=Inf, unit=1, origin=3),
              (range(model, :hyper2, lower=2, upper=4), Normal(0, 3)),
              (range(model, :hyper3, values=[:ball, :tree]), Dirichlet)]

### Algorithm

Hyperparameter ranges are sampled and concatenated into position vectors for
each swarm particle. Velocity is initiated to be zeros, and in each iteration,
every particle's position is updated to approach its personal best and the
swarm's best models so far with the equations:

\$vₖ₊₁ = w⋅vₖ + c₁⋅rand()⋅(pbest - x) + c₂⋅rand()⋅(gbest - x)\$

\$xₖ₊₁ = xₖ + vₖ₊₁\$

New models are then generated for evaluation by mutating the fields of a deep
copy of `model`. If the corresponding range has a specified `scale` function,
then the transformation is applied before the hyperparameter is returned. For
integer `NumericRange`s, the hyperparameter is rounded; and for `NominalRange`s,
the hyperparameter is sampled from the specified values with the probability
weights given by each particle.

Personal and social best models are then updated for the swarm. In order to
replicate both the probability weights and the sampled value for `NominalRange`s
of the best models, the weights of unselected values are shifted to the selected
one by the `prob_shift` factor.
"""
mutable struct ParticleSwarm{T, R<:AbstractRNG} <: MLJTuning.TuningStrategy
    n_particles::Int
    w::T
    c1::T
    c2::T
    prob_shift::T
    rng::R
    # TODO: topology
end

function ParticleSwarm(;
    n_particles::Int=3,
    w=1.0,
    c1=2.0,
    c2=2.0,
    prob_shift=0.25,
    rng::R=Random.GLOBAL_RNG
) where {R}
    T = promote_type(typeof(inv(w)), typeof.((w, c1, c2, prob_shift))...)
    swarm = ParticleSwarm{T, R}(n_particles, w, c1, c2, prob_shift, rng)
    message = MLJTuning.clean!(swarm)
    isempty(message) || @warn message
    return swarm
end

struct ParticleSwarmState{T, R, P, I}
    ranges::R
    parameters::P
    indices::I
    X::Matrix{T}
    V::Matrix{T}
    pbest_X::Matrix{T}
    gbest_X::Matrix{T}
    pbest::Vector{T}
    gbest::Vector{T}
end